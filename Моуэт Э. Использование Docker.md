parent: [[Книги]]
![[Pasted image 20240307111106.png]]

Контейнеры Docker предоставляют простые быстрые и надежные методы разработки, распространения и запуска программного обеспечения, особенно в динамических и распределенных средах. 

Из книги вы узнаете, почему контейнеры так важны, какие преимущества вы получите от применения Docker и как сделать Docker частью процесса разработки. Вы последовательно пройдете по всем этапам, необходимым для создания, тестирования и развертывания любого вебприложения, использующего Docker. 

Также вы изучите обширный материал — начиная от основ, необходимых для запуска десятка контейнеров, и заканчивая описанием сопровождения крупной системы со множеством хостов в сетевой среде со сложным режимом планирования.
Издание предназначено разработчикам, инженерам по эксплуатации и системным администраторам.


стр.21 Запуск технологии - 2013 год. 
Наконец, в 2013 году Docker стал последним штрихом в общей картине состояния
контейнеризации, и эта технология по праву заняла свое место как одно из глав-
ных направлений развития ИТ-индустрии.

Платформа Docker состоит из двух отдельных компонентов:
Docker Engine, механизма, отвечающего за создание и функционирование контей-
неров, и Docker Hub, облачного сервиса для распространения контейнеров.

Swarm – менеджер кластеров
Kitematic – графический пользовательский интерфейс для работы с контейнерами
Machine – утилита командной строки для поддержки работы Docker-хостов

Переносимость и изолированность контейнеров способствуют упрощению сотрудничества с другими разработчиками и инженерами по эксплуатации: разработчики могут быть вполне уверены в том, что их код будет работать в любых программных средах, а инженеры по эксплуатации могут сосредоточиться на организации и настройке работы контейнеров на хостах, не беспокоясь о том, какой код выполняется внутри контейнеров.

Основная цель программной среды Docker – перенести преимущества стандартизации контейнеров в область информационных технологий.

На конференции DockerConEU в декабре 2014 года был представлен Docker
Swarm, менеджер кластеров для Docker и Docker Machine, инструмент командной
строки для поддержки работы Docker-хостов

В июне 2015 года на конференции DockerCon в Сан-Франциско Соломон Хайкс (Docker) и Алекс Полви (Alex Polvi) (CoreOS) объявили о создании организации Open Container Initiative (OCI) (позже переименованной в Open Container Project) для разработки общего стандарта формата контейнеров и механизмов запуска.

Также в июне 2015 года проект FreeBSD заявил о поддержке Docker в ОС FreeBSD
с использованием файловой системы ZFS и механизма обеспечения совместимости
с ОС Linux. В августе 2015 года Docker и Microsoft совместно выпустили «предварительный технический обзор» реализации Docker Engine для Windows Server.

При выпуске версии Docker 1.8 компания Docker представила новую функцию управления надежностью содержимого контейнера, которая проверяет целостность Docker-образа и подлинность авторства стороны, опубликовавшей этот образ.

Одним из наиболее часто встречающихся вариантов использования контейнеров,
в наибольшей степени способствующим их широкому распространению, являются
микросервисы (microservices).

Микросервисы представляют собой такой способ разработки и компоновки про-
граммных систем, при котором они формируются из небольших независимых
компонентов, взаимодействующих друг с другом через сеть. Такая методика пол-
ностью противоположна традиционному «монолитному» способу разработки про-
граммного обеспечения, где создается одна большая программа, обычно написанная
на C++ или на Java.

Чтобы узнать больше о микросервисах, прочтите книги Building Microservices (англ.)
Сэма Ньюмена (Sam Newman) и Microservice Resource Guide (англ.) Мартина Фау-
лера (Martin Fowler). Русский перевод вышел в издательстве «Питер» в 2016 году.

# Установка Docker в ОС Linux

стр. 29. Установка Docker в ОС Linux Наилучшим способом установки Docker в ОС Linux является использование установочного скрипта, предоставляемого компанией Docker.

[[Эксперименты на VPS]]

# Архитектура Docker

- демон Docker (Docker daemon)
- клиент Docker
- реестры Docker используются для хранения и распространения образов.

Демон Docker загружает образы из реестров по запросу docker pull.

![[Pasted image 20240310103329.png]]

Базовые технологии
Демон Docker использует «драйвер выполнения» ( execution driver) для создания
контейнеров. По умолчанию выбирается собственный драйвер Docker **runc**, но,
кроме того, обеспечивается поддержка более старого драйвера для механизма
LXC.

Драйвер runc очень тесно связан со следующими механизмами ядра:
- **cgroups** – механизм, отвечающий за управление ресурсами, используемыми
контейнером (процессор, оперативная память и т. д.). Механизм cgroups также обеспечивает выполнение операций «замораживания» (freezing) и «размораживания» (unfreezing) контейнеров как поддержку функциональности команды docker pause;
- пространства имен (**namespaces**) отвечают за изоляцию контейнеров, гарантируют, что файловая система, имя хоста, пользователи, сетевая среда и процессы любого контейнера полностью отделены от остальной части системы.

Libcontainer также поддерживает SElinux и AppArmor, которые можно использовать для создания более строгой системы безопасности.

Еще одной основополагающей технологией для Docker является файловая система с каскадно-объединенным монтированием (Union File System – UnionFS), обеспечивающая хранение уровней для контейнеров. Функциональность UnionFS обеспечивается одним из нескольких драйверов файловой системы: AUFS, devicemapper, BTRFS или Overlay.

# Управление данными с помощью томов и контейнеров данных

Резюмируя сказанное ранее, отметим, что тома (volumes) Docker – это каталоги,
которые не являются частью файловой системы UnionFS конкретного контейнера
(см. раздел «Образы, контейнеры и файловая система Union File System» главы 3),
а представляют собой **обычные каталоги в файловой системе хоста**, но могут быть
смонтированы как отдельные файловые системы (bind mounting) (см. примечание
«Монтирование каталогов как файловых систем» ниже) внутри контейнера.

Существуют три2 различных способа инициализации томов. Важно хорошо понимать различия между этими способами. 

**Во-первых**, можно объявить том при запуске контейнера с помощью флага -v:

$ docker run -it --name container-test -h CONTAINER **-v /data** debian /bin/bash
root@CONTAINER:/#ls /data
root@CONTAINER:/#

Здесь каталог /data внутри контейнера станет томом. Любые файлы, которые
данный образ сохранил в каталоге /data, копируются на этот том. Мы можем про-
верить место расположения данного тома в файловой системе хоста, выполнив
команду docker inspect на хосте из новой командной оболочки:
$ **docker inspect -f {{.Mounts}} container-test**
[{5cad... /mnt/sda1/var/lib/docker/volumes/5cad.../_data /data local true}]

Здесь том **/data/** в контейнере представляет собой просто ссылку на каталог /
var/lib/docker/volumes/5cad.../_data в файловой системе хоста.

**Второй способ** – объявление тома с помощью инструкции VOLUME в файле Dockerfile:
FROM debian:wheezy
VOLUME /data
Результат будет в точности тот же самый, что при использовании ключа -v в ко-
манде docker run.

Установка прав доступа к тому в файле Dockerfile

FROM debian:wheezy
RUN useradd foo
RUN mkdir /data && touch /data/x
RUN chown -R foo:foo /data
VOLUME /data

**Третий способ** состоит в расширении аргумента -v команды docker run с явным
указанием связываемого каталога хоста в формате -v HOST_DIR:CONTAINER_DIR. 
Этот способ нельзя использовать в Dockerfile (так как он нарушает принцип переноси-
мости и создает угрозу безопасности). Например:
$ docker run -v /home/adrian/data:/data debian ls /data

Монтирование каталогов как файловых систем
Использование явно заданного каталога хоста в томе (синтаксис с ключом -v HOST_
DIR:CONTAINER_DIR) часто называют монтированием каталогов как файловых систем
(**bind mounting**). Это не совсем правильно, поскольку с формальной точки зрения
все тома являются каталогами, смонтированными как файловые системы. Разница лишь в том, что в одном случае точка монтирования указывается явно, а в другом она скрыта от пользователя в каталоге, принадлежащем механизму Docker.

# Совместное использование данных
Синтаксис с использованием ключа **-v HOST_DIR:CONTAINER_DIR** очень удобен для совместного использования файлов хостом и одним или несколькими контейнерами. Например, файлы конфигурации могут храниться на хосте и монтироваться внутри контейнеров, создаваемых из однотипных образов.

Также можно совместно пользоваться одними и теми же данными в нескольких
контейнерах, если указать ключ **--volumes-from CONTAINER** в команде docker run.

$ docker run -it -h NEWCONTAINER --volumes-from container-test debian /bin/bash
root@NEWCONTAINER:/# ls /data
test-file
root@NEWCONTAINER:/#

Важно отметить, что этот способ работает вне зависимости от того, активен ли в текущий момент контейнер, содержащий тома (в нашем примере это containertest). Том невозможно удалить, пока существует хотя бы один контейнер, установивший связь с этим томом.

# Контейнеры данных

На практике широко распространено создание контейнеров данных (data containers),
единственной целью которых является обеспечение совместного использования данных несколькими контейнерами. Главное преимущество такого подхода состоит в предоставлении удобного пространства имен для томов, загружаемых просто с помощью ключа --volumes-from в команде docker run.

Например, можно создать контейнер данных для СУБД PostgreSQL, выполнив следующую команду:
$ docker run **--name dbdata** postgres echo "Data-only container for postgres"

Здесь создается контейнер из образа postgres, а все тома, определенные в этом
образе, инициализируются до выполнения команды echo и выхода (завершения
команды docker run в целом). Нет необходимости оставлять контейнеры данных в активном рабочем состоянии, так как это влечет за собой лишь ненужный расход ресурсов.

В дальнейшем мы можем пользоваться томами созданного контейнера данных, применяя аргумент --volumes-from. Например:
$ docker run -d **--volumes-from dbdata** --name db1 postgres

liv@singularity:~$ docker port fsmbot-db-1
5432/tcp -> 0.0.0.0:5434
5432/tcp -> [::]:5434
